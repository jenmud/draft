{
// Stripped down OpenCypher parser for quering the graph. 
package main

import (
    "log"
    "fmt"
)

type KV struct {
    Key string
    Value []byte
}

type QueryPlan struct {
    ReadingClause []MatchQueryPlan
}

type MatchQueryPlan struct {
    Nodes []NodeQueryPlan
}

type NodeQueryPlan struct {
    Lables []string
    Properties map[string][]byte
}

func main() {
    if len(os.Args) != 2 {
        log.Fatal("Usage: cypher query 'QUERY'")
    }

    got, err := ParseReader("", strings.NewReader(os.Args[1]))
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("=", got)
}
}

Statement <- Query EOF

Query <- RegularQuery

RegularQuery <-  SingleQuery

SingleQuery <- ReadingClause _

ReadingClause <- Match {
    log.Printf("ReadingClause: %s", c.text)
    return nil, nil
}

Match <- M A T C H _ pattern:Pattern {
    plan := MatchQueryPlan{Nodes: []NodeQueryPlan{pattern.(NodeQueryPlan)}}
    log.Printf("match pattern: %#v", plan)
    return plan, nil
}

Pattern <- PatternPart 

PatternPart <- AnonymousPatternPart

AnonymousPatternPart <- PatternElement

PatternElement <- NodePattern

NodePattern <- '(' _ labels:NodeLabels? _ props:(Properties)? _ ')' {
    plan := NodeQueryPlan{}

    if labels != nil {
        plan.Lables = labels.([]string)
    }

    if props != nil {
        plan.Properties = props.(map[string][]byte)
    }

    return plan, nil
}

NodeLabels <- label:NodeLabel _ labels:(NodeLabel)*{
    l := make([]string, 1 + len(labels.([]interface{})))
    l[0] = label.(string)

    for i, label := range labels.([]interface{}) {
        l[i+1] = label.(string)
    }

    return l, nil
}

NodeLabel <- ':' _ label:String {
    return label, nil
}

Properties <- MapLiteral
ProperyKV <- key:String _ ':' _ value:(StringLiteral/Integer) {
    switch value.(type) {
    case string:
        return KV{key.(string), []byte(value.(string))}, nil
    case int64:
        return KV{key.(string), []byte(fmt.Sprintf("%d", value.(int64)))}, nil
    default:
        return nil, fmt.Errorf("Don't know what to do with %#v", value)
    }
}

MapLiteral <- '{' _ kv:ProperyKV _ '}' {
    props := make(map[string][]byte)
    k := kv.(KV)
    props[k.Key] = k.Value
    return props, nil
}

StringLiteral <- s:("'" _ String _ "'" / '"' _ String _ '"' ) {
    ss := s.([]interface{})
    return ss[2].(string), nil
}

String <- [a-zA-Z0-9]+ {
    return string(c.text), nil
}

Integer <- [0-9]+ {
    return strconv.ParseInt(string(c.text), 10, 32)
}

_ "whitespace" ← [ \t\r\n]*

A <- ('A' / 'a')
B <- ('B' / 'b')
C <- ('C' / 'c')
D <- ('D' / 'd')
E <- ('E' / 'e')
F <- ('F' / 'f')
G <- ('G' / 'g')
H <- ('H' / 'h')
I <- ('I' / 'i')
K <- ('K' / 'k')
L <- ('L' / 'l')
M <- ('M' / 'm')
N <- ('N' / 'n')
O <- ('O' / 'o')
P <- ('P' / 'p')
Q <- ('Q' / 'q')
R <- ('R' / 'r')
S <- ('S' / 's')
T <- ('T' / 't')
U <- ('U' / 'u')
V <- ('V' / 'v')
W <- ('W' / 'w')
X <- ('X' / 'x')
Y <- ('Y' / 'y')

EOF <- !.