{
// Stripped down OpenCypher parser for quering the graph. 
package main

import (
    "log"
    "fmt"
)

type QueryPlan struct {
    ReadingClause []MatchQueryPlan
}

type MatchQueryPlan struct {
    Nodes []NodeQueryPlan
}

type NodeQueryPlan struct {
    Lables []string
}

func main() {
    if len(os.Args) != 2 {
        log.Fatal("Usage: cypher query 'QUERY'")
    }

    got, err := ParseReader("", strings.NewReader(os.Args[1]))
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("=", got)
}
}

Statement <- Query EOF

Query <- RegularQuery

RegularQuery <-  SingleQuery

SingleQuery <- ReadingClause _

ReadingClause <- Match {
    log.Printf("ReadingClause: %s", c.text)
    return nil, nil
}

Match <- M A T C H _ pattern:Pattern {
    plan := MatchQueryPlan{Nodes: []NodeQueryPlan{pattern.(NodeQueryPlan)}}
    log.Printf("match pattern: %#v", plan)
    return plan, nil
}

Pattern <- PatternPart 

PatternPart <- AnonymousPatternPart

AnonymousPatternPart <- PatternElement

PatternElement <- NodePattern

NodePattern <- '(' _ labels:NodeLabels? _ ')' {
    plan := NodeQueryPlan{}

    if labels != nil {
        plan.Lables = labels.([]string)
    }

    return plan, nil
}

NodeLabels <- label:NodeLabel _ labels:(NodeLabel)* {
    l := make([]string, 1 + len(labels.([]interface{})))
    l[0] = label.(string)

    for i, label := range labels.([]interface{}) {
        l[i+1] = label.(string)
    }

    return l, nil
}

NodeLabel <- ':' _ label:String {
    return label, nil
}

String <- [a-zA-Z0-9]+ {
    return string(c.text), nil
}

_ "whitespace" ← [ \t\r\n]*

A <- ('A' / 'a')
B <- ('B' / 'b')
C <- ('C' / 'c')
D <- ('D' / 'd')
E <- ('E' / 'e')
F <- ('F' / 'f')
G <- ('G' / 'g')
H <- ('H' / 'h')
I <- ('I' / 'i')
K <- ('K' / 'k')
L <- ('L' / 'l')
M <- ('M' / 'm')
N <- ('N' / 'n')
O <- ('O' / 'o')
P <- ('P' / 'p')
Q <- ('Q' / 'q')
R <- ('R' / 'r')
S <- ('S' / 's')
T <- ('T' / 't')
U <- ('U' / 'u')
V <- ('V' / 'v')
W <- ('W' / 'w')
X <- ('X' / 'x')
Y <- ('Y' / 'y')

EOF <- !.